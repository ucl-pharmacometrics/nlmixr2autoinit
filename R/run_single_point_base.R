#' Calculate Clearance (CL) using adaptive single-point method
#'
#' Calculates drug clearance (CL) from steady-state pharmacokinetic data using an adaptive single-point approach.
#'
#' @param dat A data frame containing pharmacokinetic data. Required columns typically include `ID`, `TIME`, `DV`, `tad`, `recent_ii`, `dose`, `routeobs`, and `durationobs`.
#' @param half_life (Optional) Numeric value for the drug's half-life. If not provided, it will be estimated using `get_hf()` from pooled observations.
#' @param dose_type Type of analysis to perform. One of:
#'   \itemize{
#'     \item{\code{"first_dose"}}: First-dose analysis (default)
#'     \item{\code{"repeated_doses"}}: Analysis of doses beyond the first (e.g., steady-state)
#'     \item{\code{"combined_doses"}}: Analysis combining first and repeated doses
#'   }
#' @param pooled_ctrl A list of control settings generated by \code{\link{pooled_control}()} to define pooling rules for half-life estimation.
#' @param ssctrl A list of control parameters generated by \code{\link{ss_control}()} to guide the detection of steady-state observations.
#'
#' @details
#' This function performs clearance calculations using data collected at steady state. If the half-life is unknown, it is estimated from pooled data using control logic.
#'
#' The method identifies steady-state observations, selects peak/trough/average concentrations based on dose timing and concentration decay characteristics, and calculates individual and population-level clearance:
#' \itemize{
#'   \item Estimates half-life (if not provided) using pooled intervals.
#'   \item Detects steady-state observations using `ss_control()` rules.
#'   \item Selects minimum and maximum concentration values per interval to classify concentration type (`Css_type`).
#'   \item Calculates individual clearance as: \eqn{CL = \frac{Dose}{Css \times \tau}}.
#'   \item Computes a trimmed geometric mean of individual clearance values to reduce outlier influence.
#' }
#'
#' Supports bolus, short-term infusion, and oral administration.
#'
#' @return A list with the following elements:
#' \describe{
#'   \item{dat}{The full processed dataset, with flags for steady-state and calculated CL values.}
#'   \item{cl_df}{A subset of `dat` containing observations used in the clearance estimation.}
#'   \item{trimmed_mean_cl}{The trimmed geometric mean of clearance values across individuals.}
#' }
#'
#' @importFrom dplyr %>% filter mutate group_by ungroup select rowwise
#'
#' @examples
#' \dontrun{
#' # Bolus example
#' dat <- Bolus_1CPT
#' fdat <- processData(dat)$dat
#' half_life <- get_hf(dat = fdat)$half_life_median
#' calculate_cl(dat = fdat, half_life = half_life)
#'
#' # Infusion example
#' dat <- Infusion_1CPT
#' fdat <- processData(dat)$dat
#' half_life <- get_hf(dat = fdat)$half_life_median
#' calculate_cl(dat = fdat, half_life = half_life)
#'
#' # Oral case without pre-specified half-life
#' dat <- Oral_1CPT
#' fdat <- processData(dat)$dat
#' calculate_cl(dat = fdat, half_life = 11)
#' }
#'
#' @seealso
#' \code{\link{pooled_control}},
#' \code{\link{ss_control}},
#' \code{\link{trimmed_geom_mean}}
#'
#' @export

calculate_cl <- function(dat,
                         half_life = NULL,
                         dose_type = NULL,
                         pooled_ctrl = pooled_control(),
                         ssctrl = ss_control()) {

  `%>%` <- magrittr::`%>%`

  # Estimate half-life if not provided
  if (is.null(half_life)) {
    # Defensive check: dose_type is required when half_life is not provided
    if (is.null(half_life) && is.null(dose_type)) {
      stop("Argument 'dose_type' must be provided when 'half_life' is NULL.")
    }

    # Step 1: Generate pooled data using dose type and binning control
    pooled_data <- get_pooled_data(dat,
                                   pooled_ctrl = pooled_ctrl)

    # Step 2: Estimate the half-life from pooled data
    half_life_out <- get_hf(dat = dat,
                            pooled = pooled_data)

    half_life <- half_life_out$half_life_median

    # Defensive check: If half-life estimation failed, stop the process
    if (is.na(half_life)) {
      stop("Half-life estimation failed. Adaptive single-point method cannot proceed.")
    }
  }

  dat <- is_ss(df = dat,
               half_life = half_life,
               ssctrl = ssctrl)

  trimmed_mean_cl <- NA
  dat.ss.obs  <- NA

  dat.ss.obs <- dat %>%
    dplyr::filter(SteadyState == TRUE,!is.na(SteadyState))

  if (nrow(dat.ss.obs) <= 2) {
    return(list(
      cl_df = dat.ss.obs,
      trimmed_mean_cl = trimmed_mean_cl,
      dat = dat
    ))
  }

  # If there are multiple points within the same dose interval,
  # only the min and max values are selected for calculation
  dat.ss.obs <- dat.ss.obs %>%
    dplyr::group_by(ID, dose_number) %>%
    dplyr::mutate(
      max_value = max(DV),
      min_value = min(DV),
      max_time = tad[which.max(DV)],
      min_time = tad[which.min(DV)],
      avg_value = (max_value + min_value) / 2,
      max_interval = ifelse(DV == max(DV), TRUE, FALSE),
      min_interval = ifelse(DV == min(DV), TRUE, FALSE)
    ) %>%
    dplyr::ungroup()

  # Extract rows to be marked in dat.ss.obs
  rows_to_mark <- dat.ss.obs %>%
    dplyr::filter(max_interval == TRUE | min_interval == TRUE) %>%
    dplyr::select(ID, dose_number, TIME)

  dat <- dat %>%
    dplyr::rowwise() %>%
    dplyr::mutate(SteadyState = ifelse(
      any(
        ID == rows_to_mark$ID &
          dose_number == rows_to_mark$dose_number &
          TIME == rows_to_mark$TIME
      ),
      TRUE,
      FALSE
    )) %>%
    dplyr::ungroup()

  # Same for dat.ss.obs
  dat.ss.obs  <- dat.ss.obs  %>%
    dplyr::rowwise() %>%
    dplyr::mutate(SteadyState = ifelse(
      any(
        ID == rows_to_mark$ID &
          dose_number == rows_to_mark$dose_number &
          TIME == rows_to_mark$TIME
      ),
      TRUE,
      FALSE
    )) %>%
    dplyr::ungroup()

  # Second selectionï¼Œ only select the max, min points
  dat.ss.obs <- dat.ss.obs %>%
    dplyr::filter(SteadyState == TRUE,!is.na(SteadyState))

  # avg_value type identification
  # only for fast oral absorption when most absorption happens before Tmax
  dat.ss.obs  <-   dat.ss.obs %>%
    dplyr::mutate(
      # Init 'Css_type' to "Css_avg"
      Css_type = "Css_avg",

      # Determine Css_type using conditions
      Css_type = dplyr::case_when(
        # Condition 1: Css_avg if exp decay small
        # exp(-k * tau) >= 0.6667 means:
        # - Css_max/Css_min < 1.5
        # - Css_avg close to Css_min/max
        exp(-log(2) / half_life * recent_ii) >= 0.6667 ~ "Css_avg",

        # Condition 2: Css_avg if ratio exceeds
        # model threshold from decay curve
        max_value / min_value > exp(log(2) / half_life * recent_ii) ~ "Css_avg",

        # Condition 3: Css_max if both times
        # are in first 20% of interval
        # - Uses recent_ii (not half-life) for better robustness
        (max_time <= 0.2 * recent_ii & max_time != 0) &
          (min_time <= 0.2 * recent_ii & min_time != 0) ~ "Css_max",

        # Condition 4: Css_min if times are
        # in last 20% or if time == 0
        # - Uses recent_ii (not half-life) for better robustness
        (max_time >= 0.8 * recent_ii | max_time == 0) &
          (min_time >= 0.8 * recent_ii | min_time == 0) ~ "Css_min",

        # Default: Css_avg
        TRUE ~ Css_type
      )
    )

  dat.ss.obs <- dat.ss.obs %>%
    dplyr::mutate(
      Css_min_i = dplyr::case_when(
        Css_type == "Css_max" & routeobs == "bolus" ~
          max_value * exp(-log(2) / as.numeric(half_life) * recent_ii),
        Css_type == "Css_max" & routeobs == "infusion" ~
          max_value * exp(-log(2) / as.numeric(half_life) * (recent_ii - durationobs)),
        TRUE ~ NA_real_
      ),
      Css_max_i = dplyr::case_when(
        Css_type == "Css_min" & routeobs == "bolus" ~
          min_value / exp(-log(2) / as.numeric(half_life) * recent_ii),
        Css_type == "Css_min" & routeobs == "infusion" ~
          min_value / exp(-log(2) / as.numeric(half_life) * (recent_ii - durationobs)),
        TRUE ~ NA_real_
      ),
      Css_avg_i = dplyr::case_when(
        Css_type == "Css_avg" ~ avg_value,
        Css_type == "Css_max" ~ (max_value + Css_min_i) / 2,
        Css_type == "Css_min" ~ (min_value + Css_max_i) / 2,
        TRUE ~ NA_real_
      ),
      cl = signif(dose / Css_avg_i / recent_ii, digits = 3)
    )

  # Calculate geometric mean cl for each individual
  individual_mean_cl <-
    tryCatch(
      aggregate(cl ~ ID, data = dat.ss.obs, FUN = trimmed_geom_mean),
      error = function(e) {
        NA
      }
    )

  # Calculate the trimmed mean (e.g., 10% trimmed mean to reduce outlier impact)
  trimmed_mean_cl <-
    tryCatch(
      trimmed_geom_mean(individual_mean_cl$cl, trim = 0.05, na.rm = TRUE),
      error = function(e) {
        NA
      }
    )

  return(list(
    dat = dat,
    cl_df = dat.ss.obs,
    trimmed_mean_cl = trimmed_mean_cl
  ))

}



#' Estimate volume of distribution (Vd) from concentration Data
#'
#' Calculates the volume of distribution (Vd) for either intravenous bolus or infusion routes
#' using a adaptive single-point method. If half-life is not provided, it can be estimated using pooled data.
#'
#' @param dat A data frame containing pharmacokinetic data. Must include at least the following columns:
#'   `EVID`, `dose_number`, `tad`, `iiobs`, `TIME`, `DV`, and optionally `durationobs` and `rateobs`
#'   for infusion routes.
#' @param half_life Optional numeric value for the elimination half-life. If NULL, it will be estimated
#'   using the `get_hf()` function based on pooled data.
#' @param dose_type Character value indicating the dose type, required if `half_life` is NULL. Used
#'   internally during half-life estimation.
#' @param pooled_ctrl An optional list of control parameters used by `get_pooled_data()` for pooling
#'   observations. Defaults to output from `pooled_control()`.
#' @param route Character string specifying the route of administration. Must be one of `"bolus"`,
#'   `"oral"`, or `"infusion"`. Currently, `"oral"` is not implemented.
#'
#' @return A named list with two components:
#' \describe{
#'   \item{vd_df}{A `data.frame` of selected observations with an added `vd` column representing
#'   the calculated volume of distribution for each subject.}
#'   \item{trimmed_mean_vd}{A numeric value giving the trimmed geometric mean of individual Vd estimates,
#'   using a 5% trimming level to reduce the impact of outliers.}
#' }
#'
#' @details
#' The function uses an early concentration point (based on time since dosing and half-life)
#' to estimate Vd. For bolus:
#' \deqn{Vd = \frac{\text{Dose}}{C_0}}
#' For infusion:
#' \deqn{Vd = \frac{\text{Rate} \times \min(\text{TIME}, \text{durationobs})}{C}}
#' where `C` is the observed concentration (`DV`).
#'
#' When `half_life` is not provided, it is estimated from pooled data using
#' `get_pooled_data()` and `get_hf()`.
#'
#' @examples
#' \dontrun{
#' # Bolus example
#' dat <- Bolus_1CPT
#' out <- processData(dat)
#' fdat<- out$dat
#' froute <-out$Datainfo$Value[out$Datainfo$Infometrics == "Dose Route"]
#' half_life <- get_hf(dat = fdat)$half_life_median
#' calculate_vd(dat = fdat, half_life = half_life,route=froute)
#'
#' # Infusion example
#' dat <- Infusion_1CPT
#' out <- processData(dat)
#' fdat<- out$dat
#' froute <-out$Datainfo$Value[out$Datainfo$Infometrics == "Dose Route"]
#' half_life <- get_hf(dat = fdat)$half_life_median
#' calculate_vd(dat = fdat, half_life = half_life,route=froute)
#'
#' }
#' @export


calculate_vd <- function(dat,
                         half_life = NULL,
                         dose_type = NULL,
                         pooled_ctrl = pooled_control(),
                         route = c("bolus", "oral", "infusion")) {

  `%>%` <- magrittr::`%>%`

  # Estimate half-life if not provided
  if (is.null(half_life)) {
    # Defensive check: dose_type is required when half_life is not provided
    if (is.null(half_life) && is.null(dose_type)) {
      stop("Argument 'dose_type' must be provided when 'half_life' is NULL.")
    }

    # Step 1: Generate pooled data using dose type and binning control
    pooled_data <- get_pooled_data(dat,
                                   pooled_ctrl  = pooled_ctrl)

    # Step 2: Estimate the half-life from pooled data
    half_life_out <- get_hf(dat = dat,
                            pooled = pooled_data)

    half_life <- half_life_out$half_life_median

    # Defensive check: If half-life estimation failed, stop the process
    if (is.na(half_life)) {
      stop("Half-life estimation failed. Adaptive single-point method cannot proceed.")
    }
  }

  # ---- Defensive check: ensure route is valid ----
  route <- tryCatch(
    match.arg(route, choices = c("bolus", "oral", "infusion")),
    error = function(e) {
      stop(sprintf(
        "Invalid `route`: '%s'. Must be one of: %s.",
        as.character(route),
        paste(shQuote(c(
          "bolus", "oral", "infusion"
        )), collapse = ", ")
      ),
      call. = FALSE)
    }
  )

  trimmed_mean_vd <- NA
  dat.fd.obs <- NA

  dat <- dat %>%
    dplyr::mutate(
      C_first_flag = ifelse(
        EVID == 0 &
          dose_number == 1 &
          tad < half_life * 0.2 &
          iiobs == 0,
        1,
        0
      )
    ) %>%
    dplyr::group_by(ID) %>%
    dplyr::mutate(
      # Check if any rows meet the initial flagging condition
      has_any_C_first = any(C_first_flag == 1),
      # Compute min_time only if there are flagged rows, else NA
      min_time = ifelse(
        has_any_C_first,
        min(TIME[C_first_flag == 1], na.rm = TRUE),
        NA_real_
      ),
      # Update C_first_flag to 1 only for the earliest TIME in flagged rows
      C_first_flag = ifelse(
        C_first_flag == 1 & TIME == min_time,
        1,
        0
      )
    ) %>%
    dplyr::select(-has_any_C_first, -min_time) %>%
    dplyr::ungroup()

  dat.fd.obs <- dat %>%
    dplyr::filter(C_first_flag == 1)

  if (route == "bolus") {
    dat.fd.obs <- dat.fd.obs %>%
      dplyr::mutate(vd = signif(dose / DV, 3))

    trimmed_mean_vd <-
      trimmed_geom_mean(dat.fd.obs$vd, trim = 0.05, na.rm = TRUE)

  } else if (route == "infusion") {
    dat.fd.obs <- dat.fd.obs %>%
      dplyr::mutate(vd = signif(pmin(TIME, durationobs) * rateobs / DV, 3))

    individual_mean_vd <- tryCatch(
      dat.fd.obs %>%
        dplyr::group_by(ID) %>%
        dplyr::summarise(
          vd = trimmed_geom_mean(vd, trim = 0.05, na.rm = TRUE),
          .groups = "drop"
        ),
      error = function(e)
        NA
    )

    trimmed_mean_vd <- tryCatch(
      trimmed_geom_mean(individual_mean_vd$vd, trim = 0.05, na.rm = TRUE),
      error = function(e)
        NA
    )
  }

  return(list(vd_df = dat.fd.obs,
              trimmed_mean_vd = trimmed_mean_vd))
}



#' Run Adaptive Single-Point PK Analysis
#'
#' Computes both clearance (CL) and volume of distribution (Vd) using adaptive single-point methods
#' from pharmacokinetic data. Automatically estimates half-life if not provided.
#'
#' @param dat A data frame with pharmacokinetic data. Must include key variables such as
#'   `ID`, `DV`, `TIME`, `tad`, `recent_ii`, `dose`, `routeobs`, `iiobs`, `EVID`, etc.
#' @param route Character string. Must be one of "bolus", "oral", or "infusion".
#' @param half_life Optional numeric value. If NULL, it will be estimated from the data.
#' @param dose_type Optional character string (e.g. "bolus", "infusion"). Required if `half_life` is NULL.
#' @param pooled_ctrl Optional list of control settings from \code{\link{pooled_control}()}.
#' @param ssctrl Optional list of control settings from \code{\link{ss_control}()}.
#'
#' @return A named list with:
#' \describe{
#'   \item{summary}{A data frame with trimmed mean CL and Vd, and timestamp}
#'   \item{dat}{The updated full dataset}
#'   \item{cl_df}{Subset used for clearance calculation}
#'   \item{vd_df}{Subset used for volume distribution estimation}
#' }
#'
#' @examples
#' \dontrun{
#' dat <- Bolus_1CPT
#' out <- processData(dat)
#' fdat<- out$dat
#' froute <-out$Datainfo$Value[out$Datainfo$Infometrics == "Dose Route"]
#' half_life <- get_hf(dat = fdat)$half_life_median
#' run_single_point_base(dat = fdat, half_life = half_life,route=froute)
#' }
#'
#' @export
run_single_point_base <- function(dat,
                             route = c("bolus", "oral", "infusion"),
                             half_life = NULL,
                             dose_type = NULL,
                             pooled_ctrl = pooled_control(),
                             ssctrl = ss_control()) {
  `%>%` <- magrittr::`%>%`
  start.time <- Sys.time()

  # Defensive check for route
  route <- tryCatch(
    match.arg(route, choices = c("bolus", "oral", "infusion")),
    error = function(e) {
      stop(sprintf(
        "Invalid `route`: '%s'. Must be one of: %s.",
        as.character(route),
        paste(shQuote(c(
          "bolus", "oral", "infusion"
        )), collapse = ", ")
      ),
      call. = FALSE)
    }
  )

  # Calculate CL
  cl_out <- calculate_cl(
    dat = dat,
    half_life = half_life,
    dose_type = dose_type,
    pooled_ctrl = pooled_ctrl,
    ssctrl = ssctrl
  )
  dat <- cl_out$dat

  # Calculate Vd
  vd_out <- calculate_vd(
    dat = dat,
    half_life = half_life,
    dose_type = dose_type,
    pooled_ctrl = pooled_ctrl,
    route = route
  )

  end.time <- Sys.time()
  time.spent <-
    round(as.numeric(difftime(end.time, start.time, units = "secs")), 3)

  #  Return summary and details
  summary_df <- data.frame(
    cl = signif(cl_out$trimmed_mean_cl, 3),
    vd = signif(vd_out$trimmed_mean_vd, 3),
    start.time =  start.time,
    time.spent = time.spent
  )

  return(list(
    summary = summary_df,
    dat = dat,
    cl_df = cl_out$cl_df,
    vd_df = vd_out$vd_df
  ))
}

#' Calculate the trimmed geometric mean
#'
#' Computes the trimmed geometric mean of a numeric vector.
#' A specified proportion of the smallest and largest values is removed before calculating the geometric mean.
#'
#' @param x A numeric vector containing the values for which the trimmed geometric mean is to be calculated.
#' @param trim A numeric value between 0 and 0.5 indicating the proportion of observations
#'   to be trimmed from each end of the vector. Default is 0 (no trimming).
#' @param na.rm Logical. Should missing values (NA) be removed before computation? Defaults to TRUE.
#' @return The trimmed geometric mean of the input vector as a numeric value.
#'   If no values remain after trimming, returns `NA`.
#'
trimmed_geom_mean <- function(x, trim = 0, na.rm = TRUE) {
  if (na.rm) x <- na.omit(x)  # Remove NA values if na.rm is TRUE

  # Sort the vector and apply trimming
  x <- sort(x)
  n <- length(x)
  lower <- floor(n * trim) + 1  # Index of first value to keep
  upper <- n - floor(n * trim)  # Index of last value to keep

  # Keep only trimmed range
  x_trimmed <- x[lower:upper]

  # Calculate the geometric mean of the trimmed values
  exp(mean(log(x_trimmed), na.rm = FALSE))
}
