#' Automated Pipeline for Initial Estimates in Population Pharmacokinetic Modeling
#'
#' This function provides a comprehensive and automated framework to generate initial parameter estimates
#' for population pharmacokinetic (PK) models. It implements a non-iterative, model-informed strategy,
#' incorporating naive pooled non-compartmental analysis (NCA), graphical residual-based estimation,
#' adaptive single-point heuristics, and parameter sweeping for nonlinear and multi-compartmental models.
#' The framework is designed to support a wide range of intravenous (IV) and oral PK data scenarios.
#'
#' The methodology is described in detail by Huang et al. (2024) and is tailored for high-throughput
#' estimation in both sparse and richly sampled datasets, helping improve robustness and convergence in
#' subsequent nonlinear mixed-effects modeling.
#'
#' @param dat A `data.frame` containing pharmacokinetic observations, including dosing events
#'   (EVID = 1) and concentration-time data (EVID = 0). Required columns include `ID`, `TIME`, `EVID`, and `DV`.
#' @param control A list generated by `initsControl()` to configure pipeline options, including:
#'   - `pooled_control`: Settings for pooled data handling
#'   - `nca_control`: Configuration of NCA behavior
#'   - `ss_control`: Settings for single-point estimation
#'   - `fallback_control`: Handling of missing or invalid estimates (e.g., fixed fallback for Ka)
#'   - `selection.crteri`: Criteria for selecting the final recommended parameters ("All", "APE", "MAE", etc.)
#'
#' @return An environment of class `getPPKinits`, containing:
#' \itemize{
#'   \item `Datainfo`: Summary information about the dataset
#'   \item `Recommended_initial_estimates`: A data.frame listing parameter names, selection methods, and estimated values
#'   \item `Run.history`: All intermediate estimation results, including outputs from:
#'     - Single-point estimation
#'     - Residual graphical analysis
#'     - Pooled NCA
#'     - Wanger–Nelson estimation
#'     - Parameter sweeping for one-, two-, and three-compartment models
#'   \item `Parameter.descriptions`: A character vector explaining the meaning of each estimated parameter
#' }
#'
#' @details
#' This pipeline executes the following sequence:
#' \enumerate{
#'   \item Data preprocessing and route/type detection
#'   \item Analytical estimation via:
#'     \itemize{
#'       \item Single-point heuristics (CL, Vd, Ka)
#'       \item Residual binning methods (CL, Vd, Ka)
#'       \item Pooled NCA with optional Wanger–Nelson Ka estimation
#'     }
#'   \item Performance metrics (APE, MAE, MAPE, RMSE, rRMSE) from simulated concentration profiles using `rxSolve`
#'   \item Selection of optimal base parameter set based on a configurable criterion
#'   \item Parameter sweeping for:
#'     \itemize{
#'       \item Michaelis–Menten kinetics (Vmax, Km)
#'       \item Two- and three-compartmental PK models (Vc, Vp, Q, Q2, etc.)
#'     }
#'   \item Final recommendation of starting values for CL, Vd, Ka, Vmax, Km, and inter-compartmental parameters
#' }
#'
#' The estimation methods are non-fitting (analytical) and do not require optimization, making this tool suitable for
#' initializing nonlinear mixed-effects models in software such as NONMEM, Monolix, or nlmixr2.

#'
#' @references
#' Huang, Z., Fidler, M., Lan, M., Cheng, L.L., Kloprogge, F. et al. (2024).
#' An automated pipeline to generate initial estimates for population pharmacokinetic models.
#' Preprint. https://doi.org/10.21203/rs.3.rs-5806446/v1
#' @seealso \code{\link{initsControl}}, \code{\link{rxSolve}}, \code{\link{nlmixr2}}, \code{\link{nca_control}}
#'
#' @export
#'
#' @examples
#' \dontrun{
#' dat<-Bolus_1CPT
#' initsout <- getPPKinits(dat)
#'
#' dat<-Infusion_1CPT
#' initsout <- getPPKinits(dat)
#'
#' dat<-Oral_1CPT
#' initsout <- getPPKinits(dat)
#' }


getPPKinits <- function(dat, control=initsControl()) {

  # Unpack control components
  .pooledctrl    <- control$pooled.control
  .ncactrl       <- control$nca.control
  .ssctrl        <-  control$ss.control
  .fbctrl        <- control$fallback.control
   selection.criterion <- control$selection.criterion

  ################# 1. Data preprocessing #################

  # Record start time
  start.time <- Sys.time()

  process_result <- processData(dat)
  dat <- process_result$dat
  dose_type <-
    process_result$Datainfo$Value[process_result$Datainfo$Infometrics == "Dose Type"]
  route <-
  process_result$Datainfo$Value[process_result$Datainfo$Infometrics == "Dose Route"]
  Datainfo<-process_result$Datainfo

  # reset ID
  dat <- dat %>%
    dplyr::mutate(ID = ID + (resetflag - 1) * max(dat$ID, na.rm = TRUE))

  # obtain the pooled data
  pooled_data <- get_pooled_data(dat,
                                 dose_type,
                                 .pooledctrl)

  # estimate the half-life
  half_life_out <- get_hf(dat = dat,pooled = pooled_data)

  ##################2. Single-point method  #################
  sp_result <- run_single_point(
    dat = dat,
    route = route,
    half_life = half_life_out$half_life_median,
    dose_type = dose_type,
    pooled_ctrl = .pooledctrl,
    ssctrl = .ssctrl
  )

  dat <- sp_result$dat
  sp_out <- sp_result$singlepoint.results

  used_sp_ka_fallback  <- FALSE

  if (.fbctrl$enable_ka_fallback &&
      route == "oral" &&
      (is.na(sp_out$ka) || sp_out$ka < 0)){

      sp_out$ka <- 1

   used_sp_ka_fallback<- TRUE
  }

  ####################3. Graphical residuals  ##################
  graph_out <- run_graphcal(
    dat,
    route,
    data_type,
    pooled =  pooled_data,
    pooled_ctrl = .pooledctrl,
    nlastpoints = 3
  )

  used_graph_ka_fallback  <- FALSE
  if (.fbctrl$enable_ka_fallback &&
      route == "oral" &&
      (is.na(graph_out$ka) || graph_out$ka < 0)) {
       graph_out$ka <- 1
       used_graph_ka_fallback  <- TRUE
  }


  ###################4. Naive pooled NCA   ##################
  nca_out <- run_pooled_nca(dat,
                            dose_type=dose_type,
                            route=route,
                            pooled_ctrl=pooled_control(),
                            nca_ctrl=nca_control()
                            )
  ka_nca_fd <- NA
  ka_nca_efd <- NA
  ka_nca_all <- NA
  used_nca_fd_ka_fallback  <- FALSE
  ka_wn <-NA
  if (route == "oral" &&
      !is.na(nca_out$nca.fd.results$clobs) &&
      !is.na(nca_out$nca.fd.results$vzobs)) {
    ka_wn <- ka_wanger_nelson(
      pooled_data$datpooled_fd$binned.df,
      nca_out$nca.fd.results
    )
    ka_nca_fd <- signif(ka_wn$ka, 3)
    if (.fbctrl$enable_ka_fallback) {
      if ((is.na(ka_nca_fd) || ka_nca_fd < 0)){
           ka_nca_fd <- 1
           used_nca_fd_fallback <- TRUE
      }
           ka_nca_efd <- 1
           ka_nca_all <- 1
      }
  }

  ########## 5. Predictive performance evaluation for base parameters   ##########
  simpcal.APE <- simpcal.MAE <- simpcal.MAPE <- simpcal.RMSE <- simpcal.rRMSE <- NA
  nca.APE <- nca.MAE <- nca.MAPE <- nca.RMSE <- nca.rRMSE <- NA
  nca_fd.APE <- nca_fd.MAE <- nca_fd.MAPE <- nca_fd.RMSE <- nca_fd.rRMSE <- NA
  nca_efd.APE <- nca_efd.MAE <- nca_efd.MAPE <- nca_efd.RMSE <- nca_efd.rRMSE <- NA
  graph_fd.APE <- graph_fd.MAE <- graph_fd.MAPE <- graph_fd.RMSE <- graph_fd.rRMSE <- NA

  if (route %in% c("bolus", "infusion")) {
    if (!is.na(sp_out$cl) && !is.na(sp_out$vd)) {
      simpcal_sim <- Fit_1cmpt_iv(
        data = dat[dat$EVID != 2, ],
        est.method = "rxSolve",
        input.cl = sp_out$cl,
        input.vd = sp_out$vd,
        input.add = 0
      )
      simpcal.APE <-
        round(metrics.(pred.x = simpcal_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[1], 3)
      simpcal.MAE <-
        round(metrics.(pred.x = simpcal_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[2], 3)
      simpcal.MAPE <-
        round(metrics.(pred.x = simpcal_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[3], 3)
      simpcal.RMSE <-
        round(metrics.(pred.x = simpcal_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[4], 3)
      simpcal.rRMSE <-
        round(metrics.(pred.x = simpcal_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[5], 3)
      rm(simpcal_sim)
      gc()
    }

    if (!is.na(nca_out$nca.fd.results$clobs) &&
        !is.na(nca_out$nca.fd.results$vzobs)) {
      if (nca_out$nca.fd.results$clobs > 0 &&
          nca_out$nca.fd.results$vzobs > 0) {
        nca_fd_sim <- Fit_1cmpt_iv(
          data = dat[dat$EVID != 2, ],
          est.method = "rxSolve",
          input.cl = nca_out$nca.fd.results$clobs,
          input.vd = nca_out$nca.fd.results$vzobs,
          input.add = 0
        )
        nca_fd.APE <-
          round(metrics.(pred.x = nca_fd_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[1], 3)
        nca_fd.MAE <-
          round(metrics.(pred.x = nca_fd_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[2], 3)
        nca_fd.MAPE <-
          round(metrics.(pred.x = nca_fd_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[3], 3)
        nca_fd.RMSE <-
          round(metrics.(pred.x = nca_fd_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[4], 3)
        nca_fd.rRMSE <-
          round(metrics.(pred.x = nca_fd_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[5], 3)
        rm(nca_fd_sim)
        gc()
      }
    }
    if (!is.na(nca_out$nca.efd.results$clobs) &&
        !is.na(nca_out$nca.efd.results$vzobs)) {
      if (nca_out$nca.efd.results$clobs > 0 &&
          nca_out$nca.efd.results$vzobs > 0) {
        nca_efd_sim <- Fit_1cmpt_iv(
          data = dat[dat$EVID != 2,],
          est.method = "rxSolve",
          input.cl = nca_out$nca.efd.results$clobs,
          input.vd = nca_out$nca.efd.results$vzobs,
          input.add = 0
        )
        nca_efd.APE <-
          round(metrics.(pred.x = nca_efd_sim$cp, obs.y = dat[dat$EVID == 0, ]$DV)[1], 3)
        nca_efd.MAE <-
          round(metrics.(pred.x = nca_efd_sim$cp, obs.y = dat[dat$EVID == 0, ]$DV)[2], 3)
        nca_efd.MAPE <-
          round(metrics.(pred.x = nca_efd_sim$cp, obs.y = dat[dat$EVID == 0, ]$DV)[3], 3)
        nca_efd.RMSE <-
          round(metrics.(pred.x = nca_efd_sim$cp, obs.y = dat[dat$EVID == 0, ]$DV)[4], 3)
        nca_efd.rRMSE <-
          round(metrics.(pred.x = nca_efd_sim$cp, obs.y = dat[dat$EVID == 0, ]$DV)[5], 3)
        rm(nca_efd_sim)
        gc()
      }
    }

    if (!is.na(nca_out$nca.all.results$clobs) &&
        !is.na(nca_out$nca.all.results$vzobs)) {
      if (nca_out$nca.all.results$clobs > 0 &&
          nca_out$nca.all.results$vzobs > 0) {
        nca_all_sim <- Fit_1cmpt_iv(
          data = dat[dat$EVID != 2,],
          est.method = "rxSolve",
          input.cl = nca_out$nca.all.results$clobs,
          input.vd = nca_out$nca.all.results$vzobs,
          input.add = 0
        )
        nca.APE <-
          round(metrics.(pred.x = nca_all_sim$cp, obs.y = dat[dat$EVID == 0, ]$DV)[1], 3)
        nca.MAE <-
          round(metrics.(pred.x = nca_all_sim$cp, obs.y = dat[dat$EVID == 0, ]$DV)[2], 3)
        nca.MAPE <-
          round(metrics.(pred.x = nca_all_sim$cp, obs.y = dat[dat$EVID == 0, ]$DV)[3], 3)
        nca.RMSE <-
          round(metrics.(pred.x = nca_all_sim$cp, obs.y = dat[dat$EVID == 0, ]$DV)[4], 3)
        nca.rRMSE <-
          round(metrics.(pred.x = nca_all_sim$cp, obs.y = dat[dat$EVID == 0, ]$DV)[5], 3)
        rm(nca_all_sim)
        gc()
      }
    }
    if (!is.na(graph_out$cl) && !is.na(graph_out$vd)) {
      if (graph_out$cl > 0 && graph_out$vd > 0) {
        graph_fd_sim <- Fit_1cmpt_iv(
          data = dat[dat$EVID != 2, ],
          est.method = "rxSolve",
          input.cl = graph_out$cl,
          input.vd = graph_out$vd,
          input.add = 0
        )
        graph_fd.APE <-
          round(metrics.(pred.x = graph_fd_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[1], 3)
        graph_fd.MAE <-
          round(metrics.(pred.x = graph_fd_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[2], 3)
        graph_fd.MAPE <-
          round(metrics.(pred.x = graph_fd_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[3], 3)
        graph_fd.RMSE <-
          round(metrics.(pred.x = graph_fd_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[4], 3)
        graph_fd.rRMSE <-
          round(metrics.(pred.x = graph_fd_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[5], 3)
        rm(graph_fd_sim)
        gc()
      }
    }
  }

  if (route == "oral") {
    if (!is.na(sp_out$cl) && !is.na(sp_out$vd) && !is.na(sp_out$ka)) {
      if (sp_out$cl > 0 && sp_out$vd > 0 && sp_out$ka > 0) {
        simpcal_sim <- Fit_1cmpt_oral(
          data = dat[dat$EVID != 2, ],
          est.method = "rxSolve",
          input.ka = sp_out$ka,
          input.cl = sp_out$cl,
          input.vd = sp_out$vd,
          input.add = 0
        )
        simpcal.APE <-
          round(metrics.(pred.x = simpcal_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[1], 3)
        simpcal.MAE <-
          round(metrics.(pred.x = simpcal_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[2], 3)
        simpcal.MAPE <-
          round(metrics.(pred.x = simpcal_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[3], 3)
        simpcal.RMSE <-
          round(metrics.(pred.x = simpcal_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[4], 3)
        simpcal.rRMSE <-
          round(metrics.(pred.x = simpcal_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[5], 3)
        rm(simpcal_sim)
        gc()
      }
    }

    if (!is.na(nca_out$nca.fd.results$clobs) &&
        !is.na(nca_out$nca.fd.results$vzobs) && !is.na(ka_nca_fd)) {
      if (nca_out$nca.fd.results$clobs > 0 &&
          nca_out$nca.fd.results$vzobs > 0 && ka_nca_fd > 0) {
        nca_fd_sim <- Fit_1cmpt_oral(
          data = dat[dat$EVID != 2, ],
          est.method = "rxSolve",
          input.ka = ka_nca_fd,
          input.cl = nca_out$nca.fd.results$clobs,
          input.vd = nca_out$nca.fd.results$vzobs,
          input.add = 0
        )
        nca_fd.APE <-
          round(metrics.(pred.x = nca_fd_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[1], 3)
        nca_fd.MAE <-
          round(metrics.(pred.x = nca_fd_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[2], 3)
        nca_fd.MAPE <-
          round(metrics.(pred.x = nca_fd_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[3], 3)
        nca_fd.RMSE <-
          round(metrics.(pred.x = nca_fd_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[4], 3)
        nca_fd.rRMSE <-
          round(metrics.(pred.x = nca_fd_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[5], 3)
        rm(nca_fd_sim)
        gc()
      }
    }

    if (!is.na(nca_out$nca.efd.results$clobs) &&
        !is.na(nca_out$nca.efd.results$vzobs) && !is.na(ka_nca_efd)) {
      if (nca_out$nca.efd.results$clobs > 0 &&
          nca_out$nca.efd.results$vzobs > 0 && ka_nca_efd > 0) {
        nca_efd_sim <- Fit_1cmpt_oral(
          data = dat[dat$EVID != 2,],
          est.method = "rxSolve",
          input.ka = ka_nca_efd,
          input.cl = nca_out$nca.efd.results$clobs,
          input.vd = nca_out$nca.efd.results$vzobs,
          input.add = 0
        )
        nca_efd.APE <-
          round(metrics.(pred.x = nca_efd_sim$cp, obs.y = dat[dat$EVID == 0, ]$DV)[1], 3)
        nca_efd.MAE <-
          round(metrics.(pred.x = nca_efd_sim$cp, obs.y = dat[dat$EVID == 0, ]$DV)[2], 3)
        nca_efd.MAPE <-
          round(metrics.(pred.x = nca_efd_sim$cp, obs.y = dat[dat$EVID == 0, ]$DV)[3], 3)
        nca_efd.RMSE <-
          round(metrics.(pred.x = nca_efd_sim$cp, obs.y = dat[dat$EVID == 0, ]$DV)[4], 3)
        nca_efd.rRMSE <-
          round(metrics.(pred.x = nca_efd_sim$cp, obs.y = dat[dat$EVID == 0, ]$DV)[5], 3)
        rm(nca_efd_sim)
        gc()
      }
    }

    if (!is.na(nca_out$nca.all.results$clobs) &&
        !is.na(nca_out$nca.all.results$vzobs) && !is.na(ka_nca_all)) {
      if (nca_out$nca.all.results$clobs > 0 &&
          nca_out$nca.all.results$vzobs > 0 && ka_nca_all > 0) {
        nca_all_sim <- Fit_1cmpt_oral(
          data = dat[dat$EVID != 2,],
          est.method = "rxSolve",
          input.ka = ka_nca_all,
          input.cl = nca_out$nca.all.results$clobs,
          input.vd = nca_out$nca.all.results$vzobs,
          input.add = 0
        )
        nca.APE <-
          round(metrics.(pred.x = nca_all_sim$cp, obs.y = dat[dat$EVID == 0, ]$DV)[1], 3)
        nca.MAE <-
          round(metrics.(pred.x = nca_all_sim$cp, obs.y = dat[dat$EVID == 0, ]$DV)[2], 3)
        nca.MAPE <-
          round(metrics.(pred.x = nca_all_sim$cp, obs.y = dat[dat$EVID == 0, ]$DV)[3], 3)
        nca.RMSE <-
          round(metrics.(pred.x = nca_all_sim$cp, obs.y = dat[dat$EVID == 0, ]$DV)[4], 3)
        nca.rRMSE <-
          round(metrics.(pred.x = nca_all_sim$cp, obs.y = dat[dat$EVID == 0, ]$DV)[5], 3)
        rm(nca_all_sim)
        gc()
      }
    }

    if (!is.na(graph_out$cl) &&
        !is.na(graph_out$vd) && !is.na(graph_out$ka)) {
      if (graph_out$cl > 0 && graph_out$vd > 0 && graph_out$ka > 0) {
        graph_fd_sim <- Fit_1cmpt_oral(
          data = dat[dat$EVID != 2, ],
          est.method = "rxSolve",
          input.ka = graph_out$ka,
          input.cl = graph_out$cl,
          input.vd = graph_out$vd,
          input.add = 0
        )
        graph_fd.APE <-
          round(metrics.(pred.x = graph_fd_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[1], 3)
        graph_fd.MAE <-
          round(metrics.(pred.x = graph_fd_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[2], 3)
        graph_fd.MAPE <-
          round(metrics.(pred.x = graph_fd_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[3], 3)
        graph_fd.RMSE <-
          round(metrics.(pred.x = graph_fd_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[4], 3)
        graph_fd.rRMSE <-
          round(metrics.(pred.x = graph_fd_sim$cp, obs.y = dat[dat$EVID == 0,]$DV)[5], 3)
        rm(graph_fd_sim)
        gc()
      }
    }
  }

  ka <- c(NA,NA,NA,NA,NA)

  if (route=="oral"){
    ka <- c(
    sp_out$ka,
    graph_out$ka,
    ka_nca_fd,     # by wanger nelson
    ka_nca_efd,         # no nca for md
    ka_nca_all         # no nca for md
  )
  }

  all.out <- data.frame(
    method = c(
      "Single-point method",
      "Graphic analysis",
      "NCA (only first dose)",
      "NCA (data exclude first-dose part)",
      "NCA (all pooled)"
    ),

    ka = ka,

    cl = c(
      sp_out$cl,
      graph_out$cl,
      nca_out$nca.fd.results$clobs,
      nca_out$nca.efd.results$clobs,
      nca_out$nca.all.results$clobs
    ),

    vd = c(
      sp_out$vd,
      graph_out$vd,
      nca_out$nca.fd.results$vzobs,
      nca_out$nca.efd.results$vzobs,
      nca_out$nca.all.results$vzobs
    ),

    simAPE = c(
      simpcal.APE,
      graph_fd.APE,
      nca_fd.APE,
      nca_efd.APE,
      nca.APE
    ),

    simMAE = c(
      simpcal.MAE,
      graph_fd.MAE,
      nca_fd.MAE,
      nca_efd.MAE,
      nca.MAE
    ),

    simMAPE = c(
      simpcal.MAPE,
      graph_fd.MAPE,
      nca_fd.MAPE,
      nca_efd.MAPE,
      nca.MAPE
    ),

    simRMSE = c(
      simpcal.RMSE,
      graph_fd.RMSE,
      nca_fd.RMSE,
      nca_efd.RMSE,
      nca.RMSE
    ),

    simrRMSE = c(
      simpcal.rRMSE,
      graph_fd.rRMSE,
      nca_fd.rRMSE,
      nca_efd.rRMSE,
      nca.rRMSE
    ),

    time.spent = c(
      sp_out$time.spent,
      graph_out$time.spent,
      nca_out$nca.fd.results$time.spent,
      nca_out$nca.efd.results$time.spent,
      nca_out$nca.all.results$time.spent
    )
  )

  colnames(all.out) <- c(
    "Method",
    "Calculated Ka",
    "Calculated CL",
    "Calculated Vd",
    "Absolute Predicted Error (APE)",
    "Mean Absolute Error (MAE)",
    "Mean Absolute Percentage Error (MAPE)",
    "Root Mean Squared Error (RMSE)",
    "Relative Root Mean Squared Error (rRMSE)",
    "Time spent"
  )

  stat_cols <- colnames(all.out)[5:9]

  all.out$min_count <- rowSums(sapply(all.out[stat_cols],function(col) {
    col == min(col, na.rm = TRUE)
  }))

  if (selection.criterion == "All") {
    base.best <- all.out[which.max(all.out$min_count), ]
  } else if (selection.criterion %in% c("APE", "MAE", "MAPE", "RMSE", "rRMSE")) {
    base.best <- all.out[which.min(all.out[[paste0("Mean ", selection.criterion)]]), ]
  }

  if (nrow(base.best) > 1) {
    base.best <- base.best[1, ]
  }

  base.ka.best <- base.best$`Calculated Ka`
  base.cl.best <- base.best$`Calculated CL`
  base.vd.best <- base.best$`Calculated Vd`

  message_text <- paste0(
    "Base PK parameter analysis finished. Estimated ka: ", signif(base.ka.best, 3),
    ", estimated CL: ", signif(base.cl.best, 3),
    ", estimated Vd: ", signif(base.vd.best, 3)
  )

  cat(message_text, "\n")

################# 6. Parameter Sweeping on Vmax and Km #######################
  message(crayon::black(
    paste0("Run parameter sweeping on nonlinear eliminiation kinetics PK parameters",strrep(".", 20))))
  sim.vmax.km.results.all <- NULL

  if (route %in% c("bolus", "infusion")) {
    sim.vmax.km.results.all.i <- sim_sens_1cmpt_mm(
      dat = dat,
      sim_vmax = list(mode = "auto", est.cl = base.cl.best),
      sim_km   = list(mode = "auto"),
      sim_vd   = list(mode = "manual", values = base.vd.best),
      sim_ka   = list(mode = "manual", values = NA),
      route    = "iv"
    )
    sim.vmax.km.results.all <- rbind(sim.vmax.km.results.all, sim.vmax.km.results.all.i)
    sim.vmax.km.results.all <- sim.vmax.km.results.all %>%
      dplyr::mutate(row_id = dplyr::row_number())
  }

  if (route %in% c("oral")) {
    sim.vmax.km.results.all.i <- sim_sens_1cmpt_mm(
      dat = dat,
      sim_vmax = list(mode = "auto", est.cl = base.cl.best),
      sim_km   = list(mode = "auto"),
      sim_vd   = list(mode = "manual", values = base.vd.best),
      sim_ka   = list(mode = "manual", values = base.ka.best),
      route    = "oral"
    )
    sim.vmax.km.results.all <- rbind(sim.vmax.km.results.all, sim.vmax.km.results.all.i)
    sim.vmax.km.results.all <- sim.vmax.km.results.all %>%
      dplyr::mutate(row_id = dplyr::row_number())
  }

  ########### 7. Parameter Sweeping on Multi-Compartmental Model Parameters#####
  message(crayon::black(
    paste0("Run parameter sweeping on multi-compartmental PK parameters",strrep(".", 20))))

  # Collect identified vc from single-point extra and base.best.vd
  # Two-compartment model simulation
  sim.2cmpt.results.all <- NULL
  approx.vc.value <- sp_result$approx.vc.out$approx.vc.value

  if (route %in% c("bolus", "infusion")) {
    sim.2cmpt.results.all <- sim_sens_2cmpt(
      dat = dat,
      sim_cl  = list(mode = "manual", values = base.cl.best),
      sim_vc  = list(mode = "manual", values = c( approx.vc.value, base.vd.best)),
      sim_vp  = list(mode = "auto"),
      sim_q   = list(mode = "auto", auto.strategy = "scaled"),
      sim_ka  = list(mode = "manual", values = NA),
      route   = "iv"
    )
    sim.2cmpt.results.all <- sim.2cmpt.results.all %>%
      dplyr::mutate(row_id = dplyr::row_number())

  }

  if (route %in% c("oral")) {
    sim.2cmpt.results.all <- sim_sens_2cmpt(
      dat = dat,
      sim_cl  = list(mode = "manual", values = base.cl.best),
      sim_vc  = list(mode = "manual", values = c( approx.vc.value, base.vd.best)),
      sim_vp  = list(mode = "auto"),
      sim_q   = list(mode = "auto", auto.strategy = "scaled"),
      sim_ka  = list(mode = "manual", values = base.ka.best),
      route   = "oral"
    )
    sim.2cmpt.results.all <- sim.2cmpt.results.all %>%
      dplyr::mutate(row_id = dplyr::row_number())

    }

  # Three-compartment model simulation
  sim.3cmpt.results.all <- NULL

  if (route %in% c("bolus", "infusion")) {
    sim.3cmpt.results.all.i <- sim_sens_3cmpt(
      dat = dat,
      sim_cl   = list(mode = "manual", values = base.cl.best),
      sim_vc   = list(mode = "manual", values = c(approx.vc.value, base.vd.best)),
      sim_vp   = list(mode = "auto"),
      sim_vp2  = list(mode = "auto"),
      sim_q    = list(mode = "auto", auto.strategy = "scaled"),
      sim_q2   = list(mode = "auto", auto.strategy = "scaled"),
      sim_ka   = list(mode = "manual", values = NA),
      route    = "iv"
    )
    sim.3cmpt.results.all <- rbind(sim.3cmpt.results.all, sim.3cmpt.results.all.i)
    sim.3cmpt.results.all <- sim.3cmpt.results.all %>%
      dplyr::mutate(row_id = dplyr::row_number())

  }

  if (route %in% c("oral")) {
    sim.3cmpt.results.all.i <- sim_sens_3cmpt(
      dat = dat,
      sim_cl   = list(mode = "manual", values = base.cl.best),
      sim_vc   = list(mode = "manual", values = c( approx.vc.value, base.vd.best)),
      sim_vp   = list(mode = "auto"),
      sim_vp2  = list(mode = "auto"),
      sim_q    = list(mode = "auto", auto.strategy = "scaled"),
      sim_q2   = list(mode = "auto", auto.strategy = "scaled"),
      sim_ka   = list(mode = "manual", values = base.ka.best),
      route    = "oral"
    )
    sim.3cmpt.results.all <- rbind(sim.3cmpt.results.all, sim.3cmpt.results.all.i)
    sim.3cmpt.results.all <- sim.3cmpt.results.all %>%
      dplyr::mutate(row_id = dplyr::row_number())

  }

############### 8. Residual error sigma estimation#####################

  method_additive <- .fbctrl$sigma_method_additive
  method_proportional <-.fbctrl$sigma_method_proportional
  sigma_fallback_fraction <- .fbctrl$sigma_fallback_fraction

  # Always compute full model-based result (reused if needed)
  sigma.out <- try(getsigma(dat),silent = T)
  sigma_add <- NA_real_
  sigma_prop <- NA_real_

  # Initialize flags for fallback detection
  used_add_fallback <- FALSE
  used_prop_fallback <- FALSE

  # --- Additive error model: decide method used ---
  if (method_additive == "model") {
    # Try model-based estimate
    sigma_add <- sigma.out$summary$sigma_additive
    if (is.na(sigma_add)) {
      used_add_fallback <- TRUE
      dv_obs <- dat[dat$EVID == 0, "DV", drop = TRUE]
      dv_mean <- mean(dv_obs, na.rm = TRUE, trim = 0.05)
      sigma_add <-  sigma_fallback_fraction *  dv_mean
    }
  } else if (method_additive == "fixed_fraction") {
    used_add_fallback <- TRUE
    dv_obs <- dat[dat$EVID == 0, "DV", drop = TRUE]
    dv_mean <- mean(dv_obs, na.rm = TRUE, trim = trim)
    sigma_add <-  sigma_fallback_fraction * dv_mean
  }

  # --- Proportional error model: decide method used ---
  if (method_proportional == "model") {
    sigma_prop <- sigma.out$summary$sigma_proportional
    if (is.na(sigma_prop)) {
      used_prop_fallback <- TRUE
      sigma_prop <- sigma_fallback_fraction
    }
  } else if (method_proportional == "fixed_fraction") {
    used_prop_fallback <- TRUE
    sigma_prop <-sigma_fallback_fraction
  }

  # --- Determine method labels used ---
  method_add_used <- if (used_add_fallback) {
    "Fallback (fixed fraction)"
  } else {
    "Model-based"
  }

  method_prop_used <- if (used_prop_fallback) {
    "Fallback (fixed fraction)"
  } else {
    "Model-based"
  }

  recommended_sigma_add_init <- sigma_add
  recommended_sigma_prop_init <-sigma_prop

################## 8. Parameter Selection Selection############################
  # Identify the columns containing the statistics
  stat_cols <- c("APE", "MAE", "MAPE", "RMSE", "rRMSE")

  sim.vmax.km.results.all$min_count <-
    rowSums(sapply(sim.vmax.km.results.all[stat_cols], function(col)
      col == min(col, na.rm = TRUE)))

  sim.2cmpt.results.all$min_count <-
    rowSums(sapply(sim.2cmpt.results.all[stat_cols], function(col)
      col == min(col, na.rm = TRUE)))

  sim.3cmpt.results.all$min_count <-
    rowSums(sapply(sim.3cmpt.results.all[stat_cols], function(col)
      col == min(col, na.rm = TRUE)))

  if (selection.criterion == "All") {
    recommended_mm     <-
      sim.vmax.km.results.all[which.max(sim.vmax.km.results.all$min_count), ]
    recommended.multi1 <-
      sim.2cmpt.results.all[which.max(sim.2cmpt.results.all$min_count), ]
    recommended.multi2 <-
      sim.3cmpt.results.all[which.max(sim.3cmpt.results.all$min_count), ]

  } else if (selection.criterion %in% names(list(
    APE   = "APE",
    MAE   = "MAE",
    MAPE  = "MAPE",
    RMSE  = "RMSE",
    rRMSE = "rRMSE"
  ))) {
    col <- criteria_map[[selection.criterion]]

    recommended_mm     <-
      sim.vmax.km.results.all[which.min(sim.vmax.km.results.all[[col]]), ]
    recommended.multi1 <-
      sim.2cmpt.results.all[which.min(sim.2cmpt.results.all[[col]]), ]
    recommended.multi2 <-
      sim.3cmpt.results.all[which.min(sim.3cmpt.results.all[[col]]), ]
  } else {
    stop("Unknown selection.criterion: must be one of All, APE, MAE, MAPE, RMSE, rRMSE")
  }

  recommended_vmax_init <- recommended_mm$Vmax
  recommended_km_init <- recommended_mm$Km

  recommended_vc2cmpt_init <- recommended.multi1$Vc
  recommended_vp2cmpt_init <- recommended.multi1$Vp
  recommended_q2cmpt_init <- recommended.multi1$Vp

  recommended_vc3cmpt_init <- recommended.multi2$Vc
  recommended_vp3cmpt_init <- recommended.multi2$Vp1
  recommended_vp23cmpt_init <- recommended.multi2$Vp2
  recommended_q3cmpt_init <- recommended.multi2$Q1
  recommended_q23cmpt_init <- recommended.multi2$Q2

  # Remove these temporary global variables run before.
  # List of variables to remove
  vars_to_remove <-
    c(
      "input.add",
      "input.ka",
      "input.cl",
      "input.vc2cmpt",
      "input.vc3cmpt",
      "input.vp2cmpt",
      "input.vp3cmpt",
      "input.vp23cmpt",
      "input.q2cmpt",
      "input.q3cmpt",
      "input.q23cmpt",
      "input.vmax",
      "input.km",
      "input.vd"
    )

  # Check if variables exist and remove them
  vars_to_remove <-
    vars_to_remove[vars_to_remove %in% ls(envir = .GlobalEnv)]
  rm(list = vars_to_remove, envir = .GlobalEnv)

  ############## 9. Finally selection####################

  end.time <- Sys.time()
  time.spent <-
    round(as.numeric(difftime(end.time, start.time, units = "secs")), 3)

  # Part 1. ka,cl,vd.
  f_init_ka <- base.best$`Calculated Ka`[1]
  f_init_cl <- base.best$`Calculated CL`[1]
  f_init_vd <- base.best$`Calculated Vd`[1]

  sel.method.ka.cl.vd <- base.best$Method[1]

  if (nrow(base.best) > 1) {
    #check the total volume of distribution of two compartment
    total.vd <- recommended.multi1$vc + recommended.multi1$vp

    f_init_cl <-
      base.best[base.best$`Calculated Vd` == round(total.vd, 1),]$`Calculated CL`
    f_init_vd <-
      base.best[base.best$`Calculated Vd` == round(total.vd, 1),]$`Calculated Ka`
    sel.method.ka.cl.vd <-
      base.best[base.best$`Calculated Vd` == round(total.vd, 1),]$Method
  }

  # vmax.km
  f_init_vmax <- recommended_vmax_init
  f_init_km <- recommended_km_init
  sel.method.vmax.km <- "Parameter sweeping"

  # Multi-compartmental parameters
  f_init_vc2cmpt <-  recommended_vc2cmpt_init
  f_init_vp2cmpt <-  recommended_vp2cmpt_init
  f_init_q2cmpt <-   recommended_q2cmpt_init
  f_init_vc3cmpt <- recommended_vc3cmpt_init
  f_init_vp3cmpt <- recommended_vp3cmpt_init
  f_init_vp23cmpt <- recommended_vp23cmpt_init
  f_init_q3cmpt <- recommended_q3cmpt_init
  f_init_q23cmpt <- recommended_q23cmpt_init

  sel.method.multi <- "Parameter sweeping"

  if (route == "oral") {
    sel.method.ka <- "Wanger-nelson method"
  } else {
    sel.method.ka <- NA
  }

  if (sel.method.ka.cl.vd == "Single-point method" &
      route == "oral") {
    sel.method.ka <- "Single-point method"
    if (used_sp_ka_fallback) {
      sel.method.ka <- "Fallback (fixed Ka)"
    }
  }

  if (sel.method.ka.cl.vd == "Graphic analysis") {
    sel.method.ka <- "Methods of residuals"
    if (used_graph_ka_fallback) {
      sel.method.ka <- "Fallback (fixed Ka)"
    }
  }

  if (used_nca_fd_ka_fallback) {
    sel.method.ka <- "Fallback (fixed Ka)"
  }

  init.params.out.ka <- data.frame(method = sel.method.ka,
                                   vd = f_init_ka)

  init.params.out.cl <- data.frame(method = sel.method.ka.cl.vd,
                                   vd = f_init_cl)

  init.params.out.vd <- data.frame(method = sel.method.ka.cl.vd,
                                   vd = f_init_vd)

  init.params.out.vmax.km <-
    data.frame(method = sel.method.vmax.km,
               vmax = f_init_vmax,
               km =  f_init_km)

  init.params.out.vc.vp <- data.frame(
    method  =  sel.method.multi,
    vc2cmpt =  f_init_vc2cmpt,
    vp2cmpt =   f_init_vp2cmpt,
    q2cmpt =   f_init_q2cmpt,
    vc3cmpt =  f_init_vc3cmpt,
    vp3cmpt =  f_init_vp3cmpt,
    vp23cmpt =   f_init_vp23cmpt,
    q3cmpt =   f_init_q3cmpt,
    q23cmpt =   f_init_q23cmpt
  )

  colnames(init.params.out.ka) <- c("Method", "Ka")
  colnames(init.params.out.cl) <- c("Method", "CL")
  colnames(init.params.out.vd) <- c("Method", "Vd")
  colnames(init.params.out.vmax.km) <- c("Method", "Vmax", "Km")
  colnames(init.params.out.vc.vp) <-
    c(
      "Method",
      "Vc2cmpt",
      "Vp2cmpt",
      "Q2cmpt",
      "Vc3cmpt",
      "Vp3cmpt",
      "Vp23cmpt",
      "Q3cmpt",
      "Q23cmpt"
    )

  # Create sigma output data frame
  init.params.out.sigma <- data.frame(
    Method_add = method_add_used,
    Method_prop = method_prop_used,
    Sigma_additive = sigma_add,
    Sigma_proportional = sigma_prop
  )

  colnames(init.params.out.sigma) <-
    c("Method (sigma additive)", "Method (sigma proportional)" , "Sigma additive", "Sigma proportional")

  init.params.out.all <- list(
    init.params.ka = init.params.out.ka,
    init.params.cl = init.params.out.cl,
    init.params.vd = init.params.out.vd,
    init.params.vmax.km = init.params.out.vmax.km,
    init.params.multi = init.params.out.vc.vp,
    init.params.sigma = init.params.out.sigma
  )

  Recommended_inits_df = data.frame(
    Parameters = c(
      "Ka",
      "CL",
      "Vd",
      "Vmax",
      "Km",
      "Vc(2CMPT)",
      "Vp(2CMPT)",
      "Q(2CMPT)",
      "Vc(3CMPT)",
      "Vp(3CMPT)",
      "Vp2(3CMPT)",
      "Q(3CMPT)",
      "Q2(3CMPT)",
      "Sigma additive",
      "Sigma proportional"
    ),

    Methods = c(
      init.params.out.all$init.params.ka$Method,
      init.params.out.all$init.params.cl$Method,
      init.params.out.all$init.params.vd$Method,
      init.params.out.all$init.params.vmax.km$Method,
      init.params.out.all$init.params.vmax.km$Method,
      init.params.out.all$init.params.multi$Method,
      init.params.out.all$init.params.multi$Method,
      init.params.out.all$init.params.multi$Method,
      init.params.out.all$init.params.multi$Method,
      init.params.out.all$init.params.multi$Method,
      init.params.out.all$init.params.multi$Method,
      init.params.out.all$init.params.multi$Method,
      init.params.out.all$init.params.multi$Method,
      init.params.out.all$init.params.sigma$`Method (sigma additive)`,
      init.params.out.all$init.params.sigma$`Method (sigma proportional)`

    ),
    Values = c(
      init.params.out.all$init.params.ka$Ka,
      init.params.out.all$init.params.cl$CL,
      init.params.out.all$init.params.vd$Vd,
      init.params.out.all$init.params.vmax.km$Vmax,
      init.params.out.all$init.params.vmax.km$Km,
      init.params.out.all$init.params.multi$Vc2cmpt,
      init.params.out.all$init.params.multi$Vp2cmpt,
      init.params.out.all$init.params.multi$Q2cmpt,
      init.params.out.all$init.params.multi$Vc3cmpt,
      init.params.out.all$init.params.multi$Vp3cmpt,
      init.params.out.all$init.params.multi$Vp23cmpt,
      init.params.out.all$init.params.multi$Q3cmpt,
      init.params.out.all$init.params.multi$Q23cmpt,
      init.params.out.all$init.params.sigma$`Sigma additive`,
      init.params.out.all$init.params.sigma$`Sigma proportional`
    )
  )

  Recommended_inits_df$Values <- format(Recommended_inits_df$Values,
                                        scientific = FALSE,
                                        digits = 3)


  colnames(all.out) <-
    c(
      "Method",
      "Calculated Ka",
      "Calculated CL",
      "Calculated Vd",
      "Absolute Predicted Error (APE)",
      "Mean Absolute Error (MAE)",
      "Mean Absolute Percentage Error (MAPE)",
      "Root Mean Squared Error (RMSE)",
      "Relative Root Mean Squared Error (rRMSE)",
      "Time spent",
      "num_min_metrics"
    )
  colnames(sim.vmax.km.results.all) <-
    c(
      "Simulated Vmax",
      "Simulated Km",
      "Absolute Predicted Error (APE)",
      "Mean Absolute Error (MAE)",
      "Mean Absolute Percentage Error (MAPE)",
      "Root Mean Squared Error (RMSE)",
      "Relative Root Mean Squared Error (rRMSE)",
      "Time spent",
      "num_min_metrics"
    )
  colnames(sim.2cmpt.results.all) <-
    c(
      "Simulated Vc",
      "Simulated Vp",
      "Simulated Q",
      "Absolute Predicted Error (APE)",
      "Mean Absolute Error (MAE)",
      "Mean Absolute Percentage Error (MAPE)",
      "Root Mean Squared Error (RMSE)",
      "Relative Root Mean Squared Error (rRMSE)",
      "Time spent",
      "num_min_metrics"
    )
  colnames(sim.3cmpt.results.all) <-
    c(
      "Simulated Vc",
      "Simulated Vp",
      "Simulated Vp2",
      "Simulated Q",
      "Simulated Q2",
      "Absolute Predicted Error (APE)",
      "Mean Absolute Error (MAE)",
      "Mean Absolute Percentage Error (MAPE)",
      "Root Mean Squared Error (RMSE)",
      "Relative Root Mean Squared Error (rRMSE)",
      "Time spent",
      "num_min_metrics"
    )

  init.history <- list(
    base.out = all.out,
    single.point.out = sp_result,
    nca.out = nca_out,
    ka.wanger.nelson.out =  ka_wn,
    graph.out =   graph_out,
    sim.vmax.km = sim.vmax.km.results.all,
    sim.2cmpt = sim.2cmpt.results.all,
    sim.3cmpt = sim.3cmpt.results.all

  )

  params.descriptions <- c(
    "Ka: absorption constant rate",
    "CL: clearance",
    "Vd: volumn of distribution",
    "Vmax: maximum metobolic rate",
    "Km: Michaelis constant",
    "Vc: volume of distribution of the central compartment",
    "Vp: volume of distribution of the peripheral compartment",
    "Vp: volume of distribution of the second peripheral compartment",
    "Q: inter-compartmental clearance",
    "Q2: inter-compartmental clearance between central and second peripheral compartment",
    "Sigma additive: stanadard deviation of additive residual additive error",
    "Sigma proportional: stanadard deviation of proportional residual additive error"
  )

  output_env <- new.env()
  output_env$Datainfo <- Datainfo
  output_env$Recommended_initial_estimates <- Recommended_inits_df
  output_env$Run.history <- init.history
  output_env$time.spent <- time.spent
  output_env$Parameter.descriptions <- params.descriptions
  output_env$Omegas<- getOmegas()

  class(output_env) <- "getPPKinits"

  gc()

  return(output_env)

} # end of function


#' Print method for `getPPKinits` objects
#'
#' This function prints a summary of the results from the initial parameter estimation pipeline,
#' including data information, recommended initial estimates, and parameter descriptions.
#' It is the default S3 `print` method for objects of class `getPPKinits`.
#'
#' @param env An environment of class `getPPKinits` containing the initial parameter estimation results.
#' Expected components include:
#' \itemize{
#'   \item \code{Recommended_initial_estimates}: A data frame with estimated values and selection methods.
#'   \item \code{Parameter.descriptions}: A character vector explaining the meaning of each parameter.
#'   \item \code{time.spent} (optional): Time taken to compute the estimates.
#' }
#'
#' @return Prints a formatted summary to the console.
#'
#' @examples
#' \dontrun{
#' # Assume `env` is the output from getPPKinits()
#' print(env)
#' }
#'
#' @export
#'
# Define a custom print method for the 'getPPKinits' by S3 method
print.getPPKinits <- function(env, ...) {
  cat("===============Initial Parameter Estimation Summary ===============\n")
  # cat("Data information:\n")
  # message(crayon::black(env$Datainfo))

  cat("\nRecommended initial estimates :\n")
  print(head(env$Recommended_initial_estimates, 15))

  cat("\nTime spent :\n")
  print(paste0(env$time.spent,"s"))

  if (!is.null(env$Omegas)) {
    cat("\nETA variances and derived covariances:\n")
    print(env$Omegas)
  }

  cat("\nParameter descriptions:\n")
  print(env$Parameter.descriptions)

  cat("\n=============== End of Summary ===============\n")
}

